const fs = require('fs').promises;
const path = require('path');
const PDFDocument = require('pdfkit');
const XLSX = require('xlsx');

// Ensure reports directory exists
const ensureReportsDir = async () => {
  const reportsDir = path.join(__dirname, '../reports');
  try {
    await fs.access(reportsDir);
  } catch (error) {
    await fs.mkdir(reportsDir, { recursive: true });
  }
  return reportsDir;
};

// Generate PDF report
exports.generatePDF = async (data) => {
  try {
    const reportsDir = await ensureReportsDir();
    const fileName = `pharmacy_report_${Date.now()}.pdf`;
    const filePath = path.join(reportsDir, fileName);
    
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const stream = doc.pipe(require('fs').createWriteStream(filePath));
      
      // Header
      doc.fontSize(24).font('Helvetica-Bold')
         .text('Pharmacy Sales Report', { align: 'center' })
         .moveDown(2);
      
      // Report date
      doc.fontSize(12).font('Helvetica')
         .text(`Generated on: ${new Date(data.generatedAt).toLocaleString()}`)
         .moveDown();
      
      // Summary section
      doc.fontSize(16).font('Helvetica-Bold')
         .text('Summary', { underline: true })
         .moveDown();
      
      doc.fontSize(12).font('Helvetica')
         .text(`Total Revenue: $${data.revenue}`)
         .text(`Total Orders: ${data.totalOrders}`)
         .text(`Paid Orders: ${data.paidOrders}`)
         .text(`Top Selling Medicine: ${data.topSelling} (${data.topSellingSold} units)`)
         .text(`Approval Ratio: ${(parseFloat(data.approvalRatio) * 100).toFixed(1)}%`)
         .text(`Approved Orders: ${data.approvedCount}`)
         .text(`Declined Orders: ${data.declinedCount}`)
         .moveDown(2);
      
      // Stock levels section
      doc.fontSize(16).font('Helvetica-Bold')
         .text('Stock Levels', { underline: true })
         .moveDown();
      
      if (data.stockLevels && data.stockLevels.length > 0) {
        // Table headers
        const tableTop = doc.y;
        const col1X = 50;
        const col2X = 300;
        const col3X = 450;
        
        doc.fontSize(12).font('Helvetica-Bold')
           .text('Medicine Name', col1X, tableTop)
           .text('Stock', col2X, tableTop)
           .text('Price', col3X, tableTop);
        
        // Draw line under headers
        doc.moveTo(col1X, tableTop + 20)
           .lineTo(500, tableTop + 20)
           .stroke();
        
        // Table rows
        let currentY = tableTop + 30;
        doc.font('Helvetica');
        
        data.stockLevels.slice(0, 20).forEach((item, index) => { // Limit to 20 items
          doc.text(item.name.substring(0, 30), col1X, currentY) // Truncate long names
             .text(item.stock.toString(), col2X, currentY)
             .text(`$${item.price.toFixed(2)}`, col3X, currentY);
          currentY += 20;
          
          // Add new page if needed
          if (currentY > 700) {
            doc.addPage();
            currentY = 50;
          }
        });
        
        if (data.stockLevels.length > 20) {
          doc.moveDown().text(`... and ${data.stockLevels.length - 20} more items`);
        }
      } else {
        doc.text('No stock data available');
      }
      
      // Footer
      doc.fontSize(10)
         .text('Generated by Pharmacy Management System', 50, 750, { align: 'center' });
      
      doc.end();
      
      stream.on('finish', () => {
        resolve(filePath);
      });
      
      stream.on('error', (err) => {
        reject(err);
      });
    });
  } catch (err) {
    console.error('PDF generation error:', err);
    throw new Error('Failed to generate PDF report');
  }
};

// Generate Excel report
exports.generateExcel = async (data) => {
  try {
    const reportsDir = await ensureReportsDir();
    const fileName = `pharmacy_report_${Date.now()}.xlsx`;
    const filePath = path.join(reportsDir, fileName);
    
    // Create workbook
    const wb = XLSX.utils.book_new();
    
    // Summary sheet
    const summaryData = [
      ['Pharmacy Sales Report'],
      ['Generated on', new Date(data.generatedAt).toLocaleString()],
      [],
      ['Summary'],
      ['Total Revenue', `$${data.revenue}`],
      ['Total Orders', data.totalOrders],
      ['Paid Orders', data.paidOrders],
      ['Top Selling Medicine', data.topSelling],
      ['Top Selling Units', data.topSellingSold],
      ['Approval Ratio', `${(parseFloat(data.approvalRatio) * 100).toFixed(1)}%`],
      ['Approved Orders', data.approvedCount],
      ['Declined Orders', data.declinedCount],
    ];
    
    const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
    
    // Set column widths
    summaryWs['!cols'] = [
      { width: 20 },
      { width: 25 }
    ];
    
    // Style the header
    if (summaryWs['A1']) {
      summaryWs['A1'].s = {
        font: { bold: true, sz: 16 },
        alignment: { horizontal: 'center' }
      };
    }
    
    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
    
    // Stock levels sheet
    if (data.stockLevels && data.stockLevels.length > 0) {
      const stockData = [
        ['Medicine Name', 'Stock Quantity', 'Price per Unit', 'Total Value']
      ];
      
      data.stockLevels.forEach(item => {
        const totalValue = (item.stock * item.price).toFixed(2);
        stockData.push([
          item.name,
          item.stock,
          parseFloat(item.price.toFixed(2)),
          parseFloat(totalValue)
        ]);
      });
      
      // Add totals row
      const totalStock = data.stockLevels.reduce((sum, item) => sum + item.stock, 0);
      const totalValue = data.stockLevels.reduce((sum, item) => sum + (item.stock * item.price), 0);
      
      stockData.push([]);
      stockData.push(['TOTALS', totalStock, '', parseFloat(totalValue.toFixed(2))]);
      
      const stockWs = XLSX.utils.aoa_to_sheet(stockData);
      
      // Set column widths
      stockWs['!cols'] = [
        { width: 30 }, // Medicine name
        { width: 15 }, // Stock
        { width: 15 }, // Price
        { width: 15 }  // Total value
      ];
      
      // Style the header row
      ['A1', 'B1', 'C1', 'D1'].forEach(cell => {
        if (stockWs[cell]) {
          stockWs[cell].s = {
            font: { bold: true },
            fill: { fgColor: { rgb: 'E6E6E6' } }
          };
        }
      });
      
      XLSX.utils.book_append_sheet(wb, stockWs, 'Stock Levels');
    }
    
    // Write file
    XLSX.writeFile(wb, filePath);
    
    return filePath;
  } catch (err) {
    console.error('Excel generation error:', err);
    throw new Error('Failed to generate Excel report');
  }
};

// Generate CSV report (alternative format)
exports.generateCSV = async (data) => {
  try {
    const reportsDir = await ensureReportsDir();
    const fileName = `pharmacy_report_${Date.now()}.csv`;
    const filePath = path.join(reportsDir, fileName);
    
    const csvData = [
      'Report Type,Pharmacy Sales Report',
      `Generated,${new Date(data.generatedAt).toLocaleString()}`,
      '',
      'Summary Data',
      `Total Revenue,$${data.revenue}`,
      `Total Orders,${data.totalOrders}`,
      `Paid Orders,${data.paidOrders}`,
      `Top Selling Medicine,${data.topSelling}`,
      `Approval Ratio,${(parseFloat(data.approvalRatio) * 100).toFixed(1)}%`,
      '',
      'Stock Levels',
      'Medicine Name,Stock Quantity,Price,Total Value'
    ];
    
    if (data.stockLevels && data.stockLevels.length > 0) {
      data.stockLevels.forEach(item => {
        const totalValue = (item.stock * item.price).toFixed(2);
        csvData.push(`"${item.name}",${item.stock},${item.price},${totalValue}`);
      });
    }
    
    const csvContent = csvData.join('\n');
    await fs.writeFile(filePath, csvContent, 'utf8');
    
    return filePath;
  } catch (err) {
    console.error('CSV generation error:', err);
    throw new Error('Failed to generate CSV report');
  }
};

// Clean up old reports (call periodically)
exports.cleanupOldReports = async (daysOld = 30) => {
  try {
    const reportsDir = await ensureReportsDir();
    const files = await fs.readdir(reportsDir);
    
    const cutoffTime = Date.now() - (daysOld * 24 * 60 * 60 * 1000);
    let deletedCount = 0;
    
    for (const file of files) {
      const filePath = path.join(reportsDir, file);
      const stats = await fs.stat(filePath);
      
      if (stats.mtime.getTime() < cutoffTime) {
        await fs.unlink(filePath);
        deletedCount++;
      }
    }
    
    console.log(`Cleaned up ${deletedCount} old report files`);
    return deletedCount;
  } catch (err) {
    console.error('Report cleanup error:', err);
    throw new Error('Failed to cleanup old reports');
  }
};